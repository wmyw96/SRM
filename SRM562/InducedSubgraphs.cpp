#include <vector>
#include <map>
#include <set>
#include <queue>
#include <bitset>
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>

using namespace std;

#define X first
#define Y second
#define mk make_pair
#define rep(i, s, t) for (int i = (s); i <= (t); ++i)
#define REP(i, n) rep(i, 1, n)
#define MOD 1000000009
#define INF 1000000000
typedef pair<int, int> PII;
typedef long long LL;
typedef double LD;
const int MAX_N = 44;
class InducedSubgraphs {
public:
	
	int g[MAX_N << 1], nxt[MAX_N << 1], c[MAX_N], nm;
	int G[MAX_N][MAX_N];
	int n, K;
	LL frac[MAX_N], C[MAX_N][MAX_N];
	int sz[MAX_N][MAX_N], f[MAX_N][MAX_N], F[MAX_N][MAX_N][MAX_N][MAX_N];
	int go[MAX_N][MAX_N], bf[MAX_N][MAX_N];
	int gg[MAX_N][MAX_N];
	
	void add(int x, int y){
		g[nm] = y; nxt[nm] = c[x]; c[x] = nm; nm++;
		G[x][y] = G[y][x] = 1;
	}
	
	void dfs(int x, int p){
		if (gg[x][p]) return;
		f[x][p] = 1;
		gg[x][p] = 1;
		for (int k = c[x]; ~k; k = nxt[k]){
			int y = g[k];
			if (y == p) continue;
			dfs(y, x);
			//printf("con %d %d\n", x, y);
			sz[x][p] += sz[y][x];
			f[x][p] = f[y][x] * C[sz[x][p]][sz[y][x]] % MOD * f[x][p] % MOD;
		}
		sz[x][p] ++;
		//printf("inf(%d, %d) =   {%d,%d}\n", x, p, sz[x][p], f[x][p]);
	}
	
	inline void relax(int &x, int y){
		x += y;
		if (x >= MOD) x -= MOD;
	}
	
	int easy(){
		int len = n - 2 * K + 1;
		int ans = 0;
		REP(i, n) REP(j, n)
			if (G[i][j] == len){
				//printf("%d %d\n", i, j);
				int pi, pj;
				for (int k = c[i]; ~k; k = nxt[k])
					if (G[g[k]][j] == G[i][j] - 1) {pi = g[k]; break;}
				for (int k = c[j]; ~k; k = nxt[k])
					if (G[i][g[k]] == G[i][j] - 1) {pj = g[k]; break;}
				if (sz[i][pi] == K && sz[j][pj] == K){
					//printf("%d %d\n", i, j);
					relax(ans, LL(f[i][pi]) * f[j][pj] % MOD);
				}
			}
		return ans;
	}
	
	void dfshard(int x, int p){
		if (go[x][p])
			return;
		go[x][p] = 1;
		F[x][p][0][0] = 1;
		int A = 0;
		for (int k = c[x]; ~k; k = nxt[k]){
			int y = g[k];
			if (y == p) continue;
			dfshard(y, x);
			int B = sz[y][x];
			rep(sA, 0, A) rep(lA, 0, A)
				bf[sA][lA] = F[x][p][sA][lA], F[x][p][sA][lA] = 0;
			rep(sA, 0, A) rep(lA, 0, A)
				rep(sB, 0, B) rep(lB, 0, B){
					LL t = C[sA + sB][sA] * C[lA + lB][lB] % MOD * bf[sA][lA] % MOD
						* F[y][x][sB][lB] % MOD;
					relax(F[x][p][sA + sB][lA + lB], t);
				}
			A += B;
		}
		F[x][p][sz[x][p]][0] = F[x][p][0][sz[x][p]] = f[x][p];
	}
	int hard(){
		int ans = 0;
		int t = n - (2 * K - n);
		t /= 2;
		REP(i, n){
			dfshard(i, n + 1);
			relax(ans, F[i][n + 1][t][t]);
			//printf("%d\n", F[i][n + 1][t][t]);
		}
		//printf("%d\n", ans);
		ans = ans * frac[2 * K - n - 1] % MOD;
		return ans;
	}
	int getCount(vector <int> edge1, vector <int> edge2, int _K) {
		this->K = _K;
		n = edge1.size() + 1;
		memset(c, -1, sizeof c);
		nm = 0;
		REP(i, n) REP(j, n) G[i][j] = (i != j) * INF;
		REP(i, edge1.size()){
			add(edge1[i - 1] + 1, edge2[i - 1] + 1);
			add(edge2[i - 1] + 1, edge1[i - 1] + 1);
		}
		//REP(i, n) REP(j, n)
		//	printf("G[%d,%d] =   %d\n", i, j, G[i][j]);
		REP(k, n) REP(i, n) REP(j, n){
			if (k == i || k == j || i == j) continue;
			G[i][j] = min(G[i][j], G[i][k] + G[k][j]);
		}
		frac[0] = 1;
		REP(i, n) frac[i] = frac[i - 1] * i % MOD;
		C[0][0] = 1;
		REP(i, n){
			C[i][0] = 1;
			REP(j, i) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
		}
		if (K == 1)
			return frac[n];
		REP(i, n) dfs(i, n + 1);
		if (2 * K <= n)
			return easy();
		else return hard();
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, int p2, bool hasAnswer, int p3) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << p2;
	cout << "]" << endl;
	InducedSubgraphs *obj;
	int answer;
	obj = new InducedSubgraphs();
	clock_t startTime = clock();
	answer = obj->getCount(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p3 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	vector <int> p1;
	int p2;
	int p3;
	
	{
	// ----- test 0 -----
	int t0[] = {0,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,2};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 2;
	p3 = 2;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {0,1,3};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {2,2,2};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 3;
	p3 = 12;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {5,0,1,2,2};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {0,1,2,4,3};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 3;
	p3 = 4;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {0,0,1,1,2,2,3,3,4,4,5,5,6,6};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 11;
	p3 = 481904640;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	int t0[] = {5,9,4,10,10,0,7,6,2,1,11,8};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {0,0,10,3,0,6,1,1,12,12,7,11};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 6;
	p3 = 800;
	all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	int t0[] = {0,5,1,0,2,3,5};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {4,7,0,6,7,5,0};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 3;
	p3 = 0;
	all_right = KawigiEdit_RunTest(5, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 6 -----
	int t0[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 1;
	p3 = 890964601;
	all_right = KawigiEdit_RunTest(6, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// Given an undirected graph G and a subset of its vertices S, the subgraph of G induced by S (denoted G/S) is defined as the subgraph of the graph G such that the following two conditions are satisfied:
// 
// The set of vertices of the subgraph G/S is exactly S.
// For any two vertices x, y in S, there is an edge {x,y} in G/S if and only if there is such an edge in G.
// 
// In other words, the induced subgraph always contains all the edges of G it may contain, given its vertices.
// 
// 
// In this problem, you are given a tree G containing n vertices and a positive integer k.
// Initially, the vertices of G are numbered from 0 to n-1, inclusive.
// The objective is to change this numbering
// so that all induced subgraphs over {i, i+1, .., i+k-1} are connected, for all 0 <= i <= n-k.
// How many ways of renumbering are there?
// 
// 
// The initial tree G is given as two vector <int>s edge1 and edge2, each containing n-1 elements.
// These two vector <int>s describe the endpoints of edges. For each i, there is an edge between the vertices edge1[i] and edge2[i].
// Let C be the number of ways to renumber the vertices that satisfy the condition above.
// Your method must return (C modulo 1,000,000,009).
// 
// 
// 
// DEFINITION
// Class:InducedSubgraphs
// Method:getCount
// Parameters:vector <int>, vector <int>, int
// Returns:int
// Method signature:int getCount(vector <int> edge1, vector <int> edge2, int k)
// 
// 
// NOTES
// -A tree is a connected graph with no cycles.
// 
// 
// CONSTRAINTS
// -edge1 will contain between 1 and 40 elements, inclusive.
// -edge2 will contain the same number of elements as edge1.
// -Each element of edge1 and edge2 will be between 0 and n-1, inclusive, where n is (the number of elements in edge1) + 1.
// -A graph represented by edge1 and edge2 will be a tree.
// -k will be between 1 and n, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// {0, 1}
// {1, 2}
// 2
// 
// Returns: 2
// 
// Initially, the graph looks as follows:
// 
//    0-1-2
// 
// There are two correct ways to assign the new numbers to its vertices:
// 
//    0-1-2
// 
// and
// 
//    2-1-0
// 
// 
// 
// 1)
// {0, 1, 3}
// {2, 2, 2}
// 3
// 
// Returns: 12
// 
// The given graph:
// 
//      0-2-1
//        |
//        3
// 
// Possible numberings are as follows.
// 
//      0-1-2     0-1-3     2-1-3     3-1-2     2-1-0     3-1-0
//        |         |         |         |         |         |
//        3         2         0         0         3         2
// 
//      0-2-3     1-2-3     3-2-1     3-2-0     0-2-1     1-2-0
//        |         |         |         |         |         |
//        1         0         0         1         3         3
// 
// 
// 2)
// {5, 0, 1, 2, 2}
// {0, 1, 2, 4, 3}
// 3
// 
// Returns: 4
// 
// The given graph:
// 
//      5-0-1-2-4
//            |
//            3
// 
// Possible ways:
// 
//      0-1-2-3-4     0-1-2-3-5
//            |             |
//            5             4
// 
//      5-4-3-2-1     5-4-3-2-0
//            |             |
//            0             1
// 
// 
// 3)
// {0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6}
// {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}
// 11
// 
// Returns: 481904640
// 
// 
// 
// 4)
// {5, 9, 4, 10, 10, 0, 7, 6, 2, 1, 11, 8}
// 
// {0, 0, 10, 3, 0, 6, 1, 1, 12, 12, 7, 11}
// 
// 6
// 
// Returns: 800
// 
// 
// 
// 5)
// {0, 5, 1, 0, 2, 3, 5}
// 
// {4, 7, 0, 6, 7, 5, 0}
// 
// 3
// 
// Returns: 0
// 
// 
// 
// 6)
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
// {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20}
// 1
// 
// Returns: 890964601
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
