#include <vector>
#include <map>
#include <set>
#include <queue>
#include <bitset>
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>

using namespace std;

#define X first
#define Y second
#define mk make_pair
#define rep(i, s, t) for (int i = (s); i <= (t); ++i)
#define REP(i, n) rep(i, 1, n)
#define MOD 1000000009
typedef pair<int, int> PII;
typedef long long LL;
typedef double LD;

struct point{
	int x, y;
	point (int _x, int _y) {x = _x; y = _y;}
	point () {}
};

const int fx[4] = {1, -1, 0, 0},
		fy[4] = {0, 0, -1, 1};
class CoinsGame {
public:
	queue<pair<point, point> > q;
	char a[44][44];
	bool go[44][44][44][44];
	int R, C, n, id[44][44], c[2222][2222], fin[2222];
	
	LL power(int x, int y){
		LL a = x, ans = 1;
		for (; y; y >>= 1){
			if (y & 1) ans = ans * a % MOD;
			a = a * a % MOD;
		}
		return ans;
	}
	
	point getf(point t, int k, bool gg){
		if (gg){
			int x = t.x + fx[k ^ 1],
				y = t.y + fy[k ^ 1];
			if (x >= R || y >= C || x <= 1 || y <= 1 || a[x][y] == '#')
				return point(-1, -1);
			else return point(x, y);
		}
		else{
			int x2 = t.x + fx[k],
				y2 = t.y + fy[k];
			if (x2 >= R || y2 >= C || x2 <= 1 || y2 <= 1)
				return point(-1, -1);
			return a[x2][y2] == '#' ? t : point(-1, -1);
		}
	}
	
	int ways(vector <string> board) {
		R = board.size();
		C = board[0].size();
		n = 0;
		//printf("%d %d\n", R, C);
		
		REP(i, R + 2) REP(j, C + 2)
			a[i][j] = '~';
		REP(i, R) REP(j, C)
			a[i + 1][j + 1] = board[i - 1][j - 1];
		R += 2; C += 2;
		REP(i, R) REP(j, C)
			if (a[i][j] == '.'){
				id[i][j] = ++n;
				//printf("%d %d\n", i, j);
			}
		
		memset(go, 0, sizeof go);
		REP(i, R) REP(j, C)
			if (a[i][j] == '~')
				REP(x, R) REP(y, C){
					if (a[x][y] != '.') continue;
					q.push(mk(point(i, j), point(x, y)));
					q.push(mk(point(x, y), point(i, j)));
					go[i][j][x][y] = 1;
					go[x][y][i][j] = 1;
					//printf("go %d %d %d %d\n", i, j, x, y); 
				}
		
		while (!q.empty()){
			pair<point, point> o = q.front();
			q.pop();
			point a = o.X, b = o.Y;
			
			for (int k = 0; k < 4; ++k){
				//bool ok = 1;
				REP(ff, 4){
					point ta = getf(a, k, (ff - 1) & 1), tb = getf(b, k, (ff - 1) & 2);
					if (ta.x > 0 && tb.x > 0){
						if (0 == go[ta.x][ta.y][tb.x][tb.y]){
							go[ta.x][ta.y][tb.x][tb.y] = 1;
							q.push(mk(ta, tb));
						}
					}
				}
			}
		}
		
		c[0][0] = 1;
		REP(i, 2000){
			c[i][0] = 1;
			REP(j, i) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
		}
		
		REP(i, R) REP(j, C){
			if (id[i][j]){
				fin[id[i][j]] = 0;
				REP(k, R) REP(p, C)
					if (id[k][p] && id[k][p] != id[i][j]){
						fin[id[i][j]] += go[i][j][k][p];
						//printf("%d %d %d %d %d\n", i, j, k, p, go[i][j][k][p]);
					}
				//printf("%d\n", fin[id[i][j]]);
			}
		}
		
		int ans = 0;
		rep(s, 2, n){
			LL ls = 0;
			REP(i, n){
				int t = fin[i];
				ls += c[n - 1][s - 1] - (n - t == 1 ? 0 : c[n - t - 1][s - 1]);
				ls %= MOD;
			}
			ls = ls * power(s, MOD - 2) % MOD;
			ans += ls;
			if (ans >= MOD)
				ans -= MOD;
			if (ans < 0)
				ans += MOD;
		}
		return ans;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	CoinsGame *obj;
	int answer;
	obj = new CoinsGame();
	clock_t startTime = clock();
	answer = obj->ways(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	
	{
	// ----- test 0 -----
	string t0[] = {".."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"##.#",".###","###.","#.##"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 11;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"####","#..#","#..#","####"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 0;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"#.#.#"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 0;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"........","........","........","........","........","........","........","........"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 688856388;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// We are playing a game with some of coins on a rectangular board.
// The board is divided into unit square cells.
// Each cell is either empty, or it contains an obstacle.
// The board is given to you as a vector <string> board.
// The character '#' represents an obstacle and '.' is an empty cell.
// 
// 
// 
// When starting the game, the player places coins into some of the empty cells.
// The number of coins and their positions are chosen by the player.
// The only restriction is that the player may not place two coins into the same cell.
// 
// 
// 
// Next to the board, there are 4 buttons labeled "Left", "Right", "Up", and "Down".
// The game is played by pushing these buttons.
// When the player pushes a button, all coins will try to move one cell in the corresponding direction.
// For each coin, there can be three different outcomes:
// 
// If the next cell in the chosen direction contains an obstacle, the coin remains in its current cell.
// If there is no next cell in the chosen direction (i.e., if the coin is already on the corresponding edge of the board), the coin falls off the board.
// In all other cases, the coin moves one cell in the chosen direction. (Note that this includes the case when the destination cell currently contains another coin. In this way it may happen that there will be multiple coins in the same cell.)
// 
// 
// 
// 
// The goal of the game is to make some coins (at least one) fall off the board, while some others (at least one) still remain on the board.
// The initial configuration of coins is called good if there is a sequence of buttons that can be pushed to win the game from that configuration.
// Return the number of good initial configurations, modulo 1,000,000,009.
// 
// DEFINITION
// Class:CoinsGame
// Method:ways
// Parameters:vector <string>
// Returns:int
// Method signature:int ways(vector <string> board)
// 
// 
// CONSTRAINTS
// -board will contain between 1 and 40 elements, inclusive.
// -Every element of board will have the same length, and this length will be between 1 and 40, inclusive.
// -Each character in each element of board will be one of '#' and '.'.
// 
// 
// EXAMPLES
// 
// 0)
// {".."}
// 
// Returns: 1
// 
// The only way to win the game on this board is to start by placing a coin on each cell.
// You can then push either of the buttons Left and Right to make one coin fall off.
// 
// 1)
// {"##.#",
//  ".###",
//  "###.",
//  "#.##"}
// 
// Returns: 11
// 
// You cannot win the game if you use less than two coins.
// On this board, any configuration with at least two coins can be won (by a single push of some button).
// Hence, the answer is C(4,2) + C(4,3) + C(4,4) = 6 + 4 + 1 = 11.
// 
// 2)
// {"####",
//  "#..#",
//  "#..#",
//  "####"}
// 
// Returns: 0
// 
// You cannot win any game on this board, as you cannot make any coin fall off the board.
// 
// 3)
// {"#.#.#"}
// 
// Returns: 0
// 
// 
// 
// 4)
// {"........",
//  "........",
//  "........",
//  "........",
//  "........",
//  "........",
//  "........",
//  "........"}
// 
// Returns: 688856388
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
