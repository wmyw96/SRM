#include <vector>
#include <map>
#include <set>
#include <queue>
#include <bitset>
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>

using namespace std;

#define X first
#define Y second
#define mk make_pair
#define rep(i, s, t) for (int i = (s); i <= (t); ++i)
#define REP(i, n) rep(i, 1, n)
#define INF 1000000000
typedef pair<int, int> PII;
typedef long long LL;
typedef double LD;

const int MAX_N = 55 * 55 * 2, MAX_M = 1111111;
const int fx[4] = {1, -1, 0, 0},
		  fy[4] = {0, 0, -1, 1};
class MaxFlowAlgorithm {
	public:
	int g[MAX_M], nxt[MAX_M], c[MAX_N], h[MAX_N], flow[MAX_M], nm;
	int d[MAX_N], q[MAX_N];
	int S, T;
	
	void addedge(int x, int y, int w){
		g[nm] = y; nxt[nm] = c[x]; c[x] = nm; flow[nm] = w; nm++;
	}
	
	void add(int x, int y, int w){
		//printf("%d %d %d\n", x, y, w);
		addedge(x, y, w);
		addedge(y, x, 0);
	}
	
	bool bfs(){
		memset(d, -1, sizeof d);
		d[S] = 0;
		q[1] = S;
		for (int l = 1, r = 1; l <= r; ++l){
			int i = q[l];
			for (int k = c[i]; ~k; k = nxt[k]){
				int j = g[k];
				if (d[j] == -1 && flow[k]) d[q[++r] = j] = d[i] + 1;
			}
		}
		return d[T] != -1;
	}
	
	int dfs(int i, int now){
		int w = 0;
		if (i == T) return now;
		if (!now) return 0;
		for (int &k = c[i]; ~k; k = nxt[k]){
			int j = g[k];
			if (d[j] == d[i] + 1){
				int res;
				if (flow[k] && ((res = dfs(j, min(now - w, flow[k]))) > 0)){
					flow[k] -= res;
					flow[k ^ 1] += res;
					w += res;
					if (w == now) return w;
				}
			}
		}
		return w;
	}
	
	void init(int _S, int _T){
		memset(c, -1, sizeof c);
		nm = 0;
		S = _S; T = _T;
	}
	
	int MaxFlow(){
		int ans = 0;
		memcpy(h, c, sizeof h);
		while (bfs()){
			ans += dfs(S, INF);
			//printf("%d\n", ans);
			memcpy(c, h, sizeof c);
		}
		return ans;
	}
}Hua;

class SurroundingGame {
public:
	int getv(char c){
		if (c >= '0' && c <= '9')
			return c - '0';
		if (c >= 'a' && c <= 'z')
			return c - 'a' + 10;
		if (c >= 'A' && c <= 'Z')
			return c - 'A' + 36;
	}
	int c[55][55], b[55][55], id[55][55];
	int maxScore(vector <string> cost, vector <string> benefit) {
		int n = cost.size();
		int m = cost[0].size();
		int N = 0;
		REP(i, n) REP(j, m) c[i][j] = getv(cost[i - 1][j - 1]);
		REP(i, n) REP(j, m) b[i][j] = getv(benefit[i - 1][j - 1]);
		REP(i, n) REP(j, m) id[i][j] = ++N;
		int S = 2 * N + 1, T = 2 * N + 2;
		Hua.init(S, T);
		int ans = 0;
		REP(i, n) REP(j, m){
			if ((i + j) % 2){
				Hua.add(S, id[i][j], c[i][j]);
				Hua.add(id[i][j], id[i][j] + N, b[i][j]);
				ans += b[i][j];
				for (int k = 0; k < 4; ++k){
					int x = i + fx[k], y = j + fy[k];
					if (id[x][y])
						Hua.add(id[i][j] + N, id[x][y], INF);
				}
			}
			else{
				Hua.add(id[i][j], T, c[i][j]);
				Hua.add(id[i][j] + N, id[i][j], b[i][j]);
				ans += b[i][j];
				for (int k = 0; k < 4; ++k){
					int x = i + fx[k], y = j + fy[k];
					if (id[x][y])
						Hua.add(id[x][y], id[i][j] + N, INF);
				}
			}
		}
		ans -= Hua.MaxFlow();
		return ans;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, vector <string> p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p1[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	SurroundingGame *obj;
	int answer;
	obj = new SurroundingGame();
	clock_t startTime = clock();
	answer = obj->maxScore(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	vector <string> p1;
	int p2;
	
	{
	// ----- test 0 -----
	string t0[] = {"21","12"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"21","12"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 4;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"ZZ","ZZ"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"11","11"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 0;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"XXX","XXX","XXX"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"aaa","aZa","aaa"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 2;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"asam","atik"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"123A","45BC"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 71;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"IIIIIIII","IIWWWWII","IIWIIIII","IIWIIIII","IIWWWWII","IIIIIWII","IIIIIWII","IIWWWWII","IIIIIIII"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"IIIIIIII","II0000II","II0II0II","II0II0II","II0000II","II0II0II","II0II0II","II0000II","IIIIIIII"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 606;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Surrounding Game is a single-player game played on a rectangular grid of cells.
// Cells are considered adjacent if they share a common side.
// (Hence, each cell has at most four adjacent cells. 
// The cells on the sides and in the corners of the grid have fewer adjacent cells than the ones inside the grid.)
// 
// The game is played by placing stones into some of the cells.
// Each cell may only contain at most one stone.
// A cell is called dominated if at least one of the following two conditions holds:
// 
// The cell contains a stone.
// All cells adjacent to the cell contain stones.
// 
// 
// Each cell of the grid contains two numbers, each from 0 to 61, inclusive:
// the cost of placing a stone into the cell, and the benefit from dominating the cell.
// At the end of the game, the overall score of the player is the sum of all benefits minus the sum of all costs.
// 
// You are given the vector <string>s cost and benefit.
// The characters cost[i][j] and benefit[i][j] represent the two numbers written in the cell (i,j), using the following encoding:
// 
// Characters '0'-'9' represent numbers 0-9.
// Characters 'a'-'z' represent numbers 10-35.
// Characters 'A'-'Z' represent numbers 36-61.
// 
// 
// For example, if character 7 of element 4 of cost is 'B', the cost of placing a stone into the cell (4,7) is 37.
// 
// Calculate and return the maximal possible score for the given grid.
// 
// DEFINITION
// Class:SurroundingGame
// Method:maxScore
// Parameters:vector <string>, vector <string>
// Returns:int
// Method signature:int maxScore(vector <string> cost, vector <string> benefit)
// 
// 
// CONSTRAINTS
// -cost will contain between 2 and 20 elements, inclusive.
// -cost and benefit will contain the same number of elements.
// -Each element of cost will contain between 2 and 20 characters, inclusive.
// -Each element of cost will contain the same number of characters.
// -Each element of benefit will contain the same number of characters as element 0 of cost.
// -Each character in cost and benefit will be a character from '0'-'9','a'-'z', or 'A'-'Z'.
// 
// 
// EXAMPLES
// 
// 0)
// {"21","12"}
// {"21","12"}
// 
// Returns: 4
// 
// The optimal solution is to put stones into (0,1) and (1,0). All the cells will be dominated and the overall score will be 6 - 2 = 4.
// 
// 1)
// {"ZZ","ZZ"}
// {"11","11"}
// 
// Returns: 0
// 
// The optimal solution is to put no stones.
// It is impossible to get a positive score.
// 
// 
// 2)
// {"XXX","XXX","XXX"}
// {"aaa","aZa","aaa"}
// 
// Returns: 2
// 
// The optimal solution is to put a stone into (1,1).
// 
// 
// 3)
// {"asam","atik"}
// {"123A","45BC"}
// 
// Returns: 71
// 
// 4)
// {"IIIIIIII",
//  "IIWWWWII",
//  "IIWIIIII",
//  "IIWIIIII",
//  "IIWWWWII",
//  "IIIIIWII",
//  "IIIIIWII",
//  "IIWWWWII",
//  "IIIIIIII"}
// 
// {"IIIIIIII",
//  "II0000II",
//  "II0II0II",
//  "II0II0II",
//  "II0000II",
//  "II0II0II",
//  "II0II0II",
//  "II0000II",
//  "IIIIIIII"}
// 
// 
// Returns: 606
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
