#include <vector>
#include <map>
#include <set>
#include <queue>
#include <bitset>
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>

using namespace std;

#define X first
#define Y second
#define mk make_pair
#define rep(i, s, t) for (int i = (s); i <= (t); ++i)
#define REP(i, n) rep(i, 1, n)
typedef pair<int, int> PII;
typedef long long LL;
typedef double LD;

struct Path{
	int x, y, w;
	Path(int _x, int _y, int _w){
		x = _x; y = _y; w = _w;
	}
	Path(){}
	bool operator < (Path const &b) const{
		return (w != b.w) ? (w < b.w) : ((x != b.x) ? (x < b.x) : (y < b.y));
	}
};

const int MAX_N = 2555;
const int fx[4] = {1, -1, 0, 0},
		  fy[4] = {0, 0, -1, 1};
		  
class Orienteering {
public:
	char a[55][55];
	int d[MAX_N], qu[MAX_N];
	int g[MAX_N << 1], nxt[MAX_N << 1], c[MAX_N], nm, n;
	int s[MAX_N], sp[MAX_N], tot;
	PII q[MAX_N];
	int dd[55][55];
	int dis[333][333];
	
	void newpoint(int x, int y){
		dd[x][y] = ++n; 
		if (a[x][y] == '*'){
			sp[++tot] = n;
			s[n] = 1;
		}
	}
	void add(int x, int y){
		g[nm] = y; nxt[nm] = c[x]; c[x] = nm; nm++;
	}
	void BuildTree(PII S){
		q[1] = S;
		nm = 0;
		memset(s, 0, sizeof s);
		memset(dd, 0, sizeof dd);
		memset(c, -1, sizeof c);
		newpoint(S.X, S.Y);
		for (int l = 1, r = 1; l <= r; ++l){
			PII o = q[l];
			for (int k = 0; k < 4; ++k){
				int x = o.X + fx[k], y = o.Y + fy[k];
				if (dd[x][y] == 0 && (a[x][y] == '.' || a[x][y] == '*')){
					q[++r] = mk(x, y);
					newpoint(x, y);
					add(dd[o.X][o.Y], dd[x][y]);
					add(dd[x][y], dd[o.X][o.Y]);
				}
			}
		}
	}
	
	double calc_ans1(int s, int k){
		if (s < k) return 0;
		double res = 1.0;
		REP(i, k) res = res * (s - i + 1) / (tot - i + 1);
		return res;
	}
	
	double calc_ans2(int s, int k){
		if (s < k) return 0;
		double res = (k + 1) * (k + 2);
		REP(i, k) res = res * (s - i + 1) / (tot - i + 1);
		return res;
	}
	
	void bfs(int S){
		qu[1] = S;
		memset(d, -1, sizeof d);
		d[S] = 0;
		for (int l = 1, r = 1; l <= r; ++l){
			int i = qu[l];
			for (int k = c[i]; ~k; k = nxt[k]){
				int j = g[k];
				if (d[j] == -1){
					d[qu[++r] = j] = d[i] + 1;
				}
			}
		}
	}
	
	int R, C;
	double ans1, ans2;
	
	double expectedLength(vector <string> field, int K) {
		R = field.size();
		C = field[0].size();
		REP(i, R) REP(j, C) a[i][j] = field[i - 1][j - 1];
		int fd = 0;
		REP(i, R) {
			if (fd) break;
			REP(j, C)
				if (a[i][j] != '#'){
					BuildTree(mk(i, j));
					fd = 1;
					break;
				}
		}
		ans1 = n - 1;
		for (int i = n; i >= 1; --i){
			for (int k = c[i]; ~k; k = nxt[k]){
				if (k & 1) continue;
				int j = g[k];
				s[i] += s[j];
				ans1 -= calc_ans1(s[j], K);
				ans1 -= calc_ans1(tot - s[j], K);
			}
		}
		REP(i, tot){
			bfs(sp[i]);
			REP(j, tot)
				dis[i][j] = d[sp[j]];
		}
		REP(i, tot) rep(j, i + 1, tot){
			int fbc = 0;
			REP(k, tot) if (k != i && k != j){
				if (dis[i][k] > dis[i][j]) continue;
				if (dis[j][k] > dis[i][j]) continue;
				if (dis[i][k] == dis[i][j] && k < j) continue;
				if (dis[j][k] == dis[i][j] && k < i) continue;
				fbc++;
			}
			ans2 += dis[i][j] * calc_ans2(fbc, K - 2);
		}
		ans2 = ans2 / ((tot - K + 1) * (tot - K + 2));
		return ans1 * 2 - ans2;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, int p1, bool hasAnswer, double p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << p1;
	cout << "]" << endl;
	Orienteering *obj;
	double answer;
	obj = new Orienteering();
	clock_t startTime = clock();
	answer = obj->expectedLength(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == answer && fabs(p2 - answer) <= 1e-9 * max(1.0, fabs(p2));
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	double p2;
	
	{
	// ----- test 0 -----
	string t0[] = {"*#..#",".#*#.","*...*"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 2;
	p2 = 3.8333333333333353;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"*#..#",".#*#.","*...*"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 4;
	p2 = 8.0;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"#.#**","....#","#*#**","**#*#","#..##","*#..#",".#.#.","....*"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 3;
	p2 = 10.825000000000024;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"###################","#*###############*#","#.....#######.....#","#*###*.#.*.#.*###*#","#*####*.*#*.*####*#","#*#####*###*#####*#","###################"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 9;
	p2 = 30.272233648704244;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"**##*.**#..#.*...*#...*#..#.##..#..#.#*...#.##*##.",".#..###..#..#.#.##..#.#.*#.*..#..#.#*..##.#*...*..","..#.....###.#*.##..#.#.#*..#.#..#....#..#...#*####",".#.##*#.*#..#*#*.#.#...*.#.*#.#.##.#*.##.#.#..*...","..*.*#*.###.#..#.#..##.##.*#..#.....#.....#..#.#.#",".#.##.#..##..*#..#.#...#*##*#*..#.#.#.#.##.##.#.#*","..##....#..#.#*#...*.##...#.#.####...#.#*.....#...",".#.*#.##.*#*.#*.#.#.#..#.#..#.#*#.###..##.##.#.##*",".*.#*..*.#.#...#.*##.#.**.#.*...**..*#..#.#.#*.#..",".#*.#*##....##.#.#*..*.###.#.##.##.#.#.#....#.#*.#","*.#..#*#.#*#*....#.#.#..*#**...##.#.#.**#*##.*.#..",".#*.##..##..##.#.#..#.#.###.###...#...#*#..##*#.#.","#..#*.#..*.###..#.#...#.###.#.#*#.#.#**##.#...*.#*","..#..#.#.##.#..#.**.##*#.#**.**..#.#..#...#.##*#..",".#*#.#.*..#.*#...#.#...#...#.##.#..*#*.##*....###.",".*.#.#.#.#*#..*##.**.##*##..#.*#.#*###..*.#.##.#..",".#......#...#.#.*#.#.#..#..#.#*#....#*.#*#.*#..*.#","#..####..#*#...#*.#..#.###...#.#.#.###*#..##*##.#.",".#.*..#.#...#.#..#.##...#..#.#.#.#.###..##..*."
			"*.*.",".#.#.#.#..##.*..#.*.#.##.#..##*...#.#..#.#.##.#.##",".#..#*.#.#..#.##..##..#.*..#.*#.#...##....#...###.",".#.#.#.#*.#.#..#.#..#..#.#.*#...#.##...#.##.##.*..",".#...#.#.##.#.#..*#.*#..###..#.#.#*###.##...#*.##.",".#.##.*.......*.#.*#.#.#*###..*...*..#.*.##.#.#..#","...###*####*#.#..##*...#..#..##.#.#.#..##*#*.*.*#.","#.#.#....*#..#.#.#.#.##..#*.#...#..#.#*#...#.##.*.","..*.#*##.#.#*#.###...#..##.#.#.#*###*#.*#.#.*###.#","##*##..##...#.....##.#.#.**#..#*.....##.#..#*.#.*.",".....#.*.##..##.##*.*#...#.#.#.##.#*#.**..#..#.#.#","##.#.#*##.#.#.*.*.#.#*#.#.#....*...#*##*##.#....#.","*.**#**....*..##.#*.*.**..##.###.##.....##...##.**","#.####.##*#*##..#.*#*#.##*...#.##..#.##....#*..##.","....#...##.#...#*.#..##.##.#*..*.#....##.#.*##...#","#.#..*##*..#.#..#..#..#*....#.##..##.#*##.##.*##..","..#.#*.*.##.#.#*#.#*##.###.##...#............#*.#.","#.#.##.#....*....*..##..*#.#.#.###.#.#.#.###..#..#",".#**..#*#.#*#*#.#.#...*##....##.#*..#..#*..*#..#..","...#*#.....#..#.#..#*#.*##.#..#.#.##..#."
			"*#*#.#...#",".#*.###.#.#.#.#.*#*##.##..#.#*..#...#.#.#..#*.*#..","#*.#.#.#..#..#..#....*#.*##..##.#.#..#...##.#.#..#","*.#..#..#...#..##.#*#..#.#*#.#.#.###..#.#*...#.#..","#...#.#...#.#.#..#.*.#*.....**.*..#*##.#*.##....##","#*#....#*#..#.*.###*#..#*##.##.#.#...#.*.##.##.##.","..##*##*..#*#.#..#*.*##*.##.#...#.#.#.#.#..*#.##..","#...#*##.#*#**.##.*#.*.##..*.#*#**....#**##...*.*#","*#.##......*#.##.#.#.##**.#.#.#.#.#.##..#...#*#*#*","*....##.#.#..#.....#..##.#....*....#.#.##.#.#.##**","#.##*#...#..#.#.##..#..##.##.##.##........##.#*#.#","..#...#.#*#*..*#..*#.*#.#......##.#.#.#*#..#..****",".###.#..#...#.#..#..#.#...#.#.#...**.#..*#*.*##*#."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 150;
	p2 = 1309.4951033725558;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Mrs. Jeipouju is planning to practice orienteering.
// The area where she'll practice is a rectangular field divided into unit squares.
// You are given its description as a vector <string> field.
// Each character in field is '.' (a period), '*' (an asterisk), or '#' (a number sign).
// Each '.' represents a passable square without a checkpoint, each '*' represents a passable square with a checkpoint, and each '#' represents an impassable obstacle.
// It is guaranteed that all passable squares (i.e., all '.'s and '*'s) form a 4-connected tree (see notes for formal definition).
// The number of checkpoints is at most 300.
// 
// 
// In order to practice, Mrs. Jeipouju chooses K of the checkpoints uniformly at random.
// Afterwards, she will find the shortest sequence of squares that passes through all chosen checkpoints.
// The sequence can start at any square, end at any square (possibly other than the starting one), and visit each square any number of times.
// Each pair of consecutive squares in the sequence must have a common side.
// The length of the sequence is the number of moves Mrs. Jeipouju will have to make.
// (So, for example, a sequence that consists of 7 squares has length 6.)
// 
// 
// You are given the vector <string> field and the int K.
// Return the expected length of Mrs. Jeipouju's sequence.
// 
// DEFINITION
// Class:Orienteering
// Method:expectedLength
// Parameters:vector <string>, int
// Returns:double
// Method signature:double expectedLength(vector <string> field, int K)
// 
// 
// NOTES
// -A set S of squares is said to form a 4-connected tree if for any two squares A and B from S, there exists exactly one way to walk from A to B while visiting only the squares from S and not visiting the same square more than once. From a given square, it is possible to walk into any square that shares a common side with it.
// 
// 
// CONSTRAINTS
// -field will contain between 1 and 50 elements, inclusive.
// -Each element of field will contain between 1 and 50 characters, inclusive.
// -Each element of field will contain the same number of characters.
// -Each character in field will be '*', '.', or '#'.
// -'*' and '.' form a 4-connected tree.
// -K will be between 2 and 300, inclusive.
// -field will contain between K and 300 '*', inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// {"*#..#",
//  ".#*#.",
//  "*...*"}
// 2
// 
// Returns: 3.8333333333333353
// 
// Let (i,j) be the square represented by the j-th character of the i-th element of field (both numbers are 0-based).
// 
// 
// If she chooses (0,0) and (1,2), one of the optimal sequences is (0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2) -> (1,2).
// If she chooses (0,0) and (2,0), one of the optimal sequences is (0,0) -> (1,0) -> (2,0).
// If she chooses (0,0) and (2,4), one of the optimal sequences is (0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2) -> (2,3) -> (2,4).
// If she chooses (1,2) and (2,0), one of the optimal sequences is (1,2) -> (2,2) -> (2,1) -> (2,0).
// If she chooses (1,2) and (2,4), one of the optimal sequences is (1,2) -> (2,2) -> (2,3) -> (2,4).
// If she chooses (2,0) and (2,4), one of the optimal sequences is (2,0) -> (2,1) -> (2,2) -> (2,3) -> (2,4).
// 
// So the expected length of her sequences is (5 + 2 + 6 + 3 + 3 + 4) / 6 = 23 / 6.
// 
// 1)
// {"*#..#",
//  ".#*#.",
//  "*...*"}
// 4
// 
// Returns: 8.0
// 
// Mrs. Jeipouju chooses all four checkpoints. One of the shortest sequences is (0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2) -> (1,2) -> (2,2) -> (2,3) -> (2,4).
// 
// 2)
// {"#.#**",
//  "....#",
//  "#*#**",
//  "**#*#",
//  "#..##",
//  "*#..#",
//  ".#.#.",
//  "....*"}
// 3
// 
// Returns: 10.825000000000024
// 
// 
// 
// 3)
// {"###################",
//  "#*###############*#",
//  "#.....#######.....#",
//  "#*###*.#.*.#.*###*#",
//  "#*####*.*#*.*####*#",
//  "#*#####*###*#####*#",
//  "###################"}
// 9
// 
// Returns: 30.272233648704244
// 
// 
// 
// 4)
// {"**##*.**#..#.*...*#...*#..#.##..#..#.#*...#.##*##.",
//  ".#..###..#..#.#.##..#.#.*#.*..#..#.#*..##.#*...*..",
//  "..#.....###.#*.##..#.#.#*..#.#..#....#..#...#*####",
//  ".#.##*#.*#..#*#*.#.#...*.#.*#.#.##.#*.##.#.#..*...",
//  "..*.*#*.###.#..#.#..##.##.*#..#.....#.....#..#.#.#",
//  ".#.##.#..##..*#..#.#...#*##*#*..#.#.#.#.##.##.#.#*",
//  "..##....#..#.#*#...*.##...#.#.####...#.#*.....#...",
//  ".#.*#.##.*#*.#*.#.#.#..#.#..#.#*#.###..##.##.#.##*",
//  ".*.#*..*.#.#...#.*##.#.**.#.*...**..*#..#.#.#*.#..",
//  ".#*.#*##....##.#.#*..*.###.#.##.##.#.#.#....#.#*.#",
//  "*.#..#*#.#*#*....#.#.#..*#**...##.#.#.**#*##.*.#..",
//  ".#*.##..##..##.#.#..#.#.###.###...#...#*#..##*#.#.",
//  "#..#*.#..*.###..#.#...#.###.#.#*#.#.#**##.#...*.#*",
//  "..#..#.#.##.#..#.**.##*#.#**.**..#.#..#...#.##*#..",
//  ".#*#.#.*..#.*#...#.#...#...#.##.#..*#*.##*....###.",
//  ".*.#.#.#.#*#..*##.**.##*##..#.*#.#*###..*.#.##.#..",
//  ".#......#...#.#.*#.#.#..#..#.#*#....#*.#*#.*#..*.#",
//  "#..####..#*#...#*.#..#.###...#.#.#.###*#..##*##.#.",
//  ".#.*..#.#...#.#..#.##...#..#.#.#.#.###..##..*.*.*.",
//  ".#.#.#.#..##.*..#.*.#.##.#..##*...#.#..#.#.##.#.##",
//  ".#..#*.#.#..#.##..##..#.*..#.*#.#...##....#...###.",
//  ".#.#.#.#*.#.#..#.#..#..#.#.*#...#.##...#.##.##.*..",
//  ".#...#.#.##.#.#..*#.*#..###..#.#.#*###.##...#*.##.",
//  ".#.##.*.......*.#.*#.#.#*###..*...*..#.*.##.#.#..#",
//  "...###*####*#.#..##*...#..#..##.#.#.#..##*#*.*.*#.",
//  "#.#.#....*#..#.#.#.#.##..#*.#...#..#.#*#...#.##.*.",
//  "..*.#*##.#.#*#.###...#..##.#.#.#*###*#.*#.#.*###.#",
//  "##*##..##...#.....##.#.#.**#..#*.....##.#..#*.#.*.",
//  ".....#.*.##..##.##*.*#...#.#.#.##.#*#.**..#..#.#.#",
//  "##.#.#*##.#.#.*.*.#.#*#.#.#....*...#*##*##.#....#.",
//  "*.**#**....*..##.#*.*.**..##.###.##.....##...##.**",
//  "#.####.##*#*##..#.*#*#.##*...#.##..#.##....#*..##.",
//  "....#...##.#...#*.#..##.##.#*..*.#....##.#.*##...#",
//  "#.#..*##*..#.#..#..#..#*....#.##..##.#*##.##.*##..",
//  "..#.#*.*.##.#.#*#.#*##.###.##...#............#*.#.",
//  "#.#.##.#....*....*..##..*#.#.#.###.#.#.#.###..#..#",
//  ".#**..#*#.#*#*#.#.#...*##....##.#*..#..#*..*#..#..",
//  "...#*#.....#..#.#..#*#.*##.#..#.#.##..#.*#*#.#...#",
//  ".#*.###.#.#.#.#.*#*##.##..#.#*..#...#.#.#..#*.*#..",
//  "#*.#.#.#..#..#..#....*#.*##..##.#.#..#...##.#.#..#",
//  "*.#..#..#...#..##.#*#..#.#*#.#.#.###..#.#*...#.#..",
//  "#...#.#...#.#.#..#.*.#*.....**.*..#*##.#*.##....##",
//  "#*#....#*#..#.*.###*#..#*##.##.#.#...#.*.##.##.##.",
//  "..##*##*..#*#.#..#*.*##*.##.#...#.#.#.#.#..*#.##..",
//  "#...#*##.#*#**.##.*#.*.##..*.#*#**....#**##...*.*#",
//  "*#.##......*#.##.#.#.##**.#.#.#.#.#.##..#...#*#*#*",
//  "*....##.#.#..#.....#..##.#....*....#.#.##.#.#.##**",
//  "#.##*#...#..#.#.##..#..##.##.##.##........##.#*#.#",
//  "..#...#.#*#*..*#..*#.*#.#......##.#.#.#*#..#..****",
//  ".###.#..#...#.#..#..#.#...#.#.#...**.#..*#*.*##*#."}
// 150
// 
// Returns: 1309.4951033725558
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
