# 250pt
## 算法描述
直接dp即可。
## 备注
+0
## tags
dp

# 500pt
## 题目描述
给定R行C列的矩阵初始都是0，让你对行做cR次xor操作，对列做cC次xor操作，最后恰好有S个是1，问操作方案数
## 算法描述
暴力枚举有几行和几列xor了奇数次，然后用组合数即可。

# 1000pt
## another
这题略坑啊。
题目描述很坑爹，感觉就是为了套上去而做的。
## 题目描述
有一种代码，有四种操作，是针对的一个0/1序列，需要一个head，分别为<(head左移一位)，>(head右移一位)，0(把当前为变成0)，1(把当前位变成1)。
然后给你一个代码code，|code|<=500，告诉你最后的序列的样子goal，|goal|<=36，问初始的序列有多少种。
注意，无论代码执行到哪里head都要在序列中（即使代码停止了），但是代码可以执行一段就停止。
## 算法描述
首先，可以对于起始位置s在[L,R]上执行代码的会让哪些位置变成*，这里的*表示可以随便填，然后对这个进行容斥，暴力的复杂度是O(2^{R-L+1})的，这个最大会到达2^36，显然是不能过的。
那么我们考虑分类讨论，因为序列的长度len应该和K=R-L+1满足len+K=n，考虑到如果我选了初始位置为i的集合来容斥，那么，如果一旦选到初始位置为i+len+1的话，那么只会-1或者+1，这个要搜起来很不合算，那么，我们就可以精巧地用组合数先处理掉这些东西然后只要O(2^len)来容斥就可以了。
## 备注
WA #1 if (R < 1) return 0;这句话写成了if (R < L) return 0;对于L和R到底是什么搞混了，然后调的时候没有改这一部分。
## tags
容斥原理，组合数，平衡规划，折半搜索。