#include <vector>
#include <map>
#include <set>
#include <queue>
#include <bitset>
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>

using namespace std;

#define X first
#define Y second
#define mk make_pair
#define rep(i, s, t) for (int i = (s); i <= (t); ++i)
#define REP(i, n) rep(i, 1, n)
typedef pair<int, int> PII;
typedef long long LL;
typedef double LD;

class HatRack {
public:
	int c[111], nxt[111], g[111], nm, ok[111], lg[111];
	struct HF{
		LL ans;
		int s;
		HF (LL _ans, int _s){
			ans = _ans; s = _s;
		}
		HF () {}
	};
	void add(int x, int y){
		g[nm] = y; nxt[nm] = c[x]; c[x] = nm; nm++;
	}
	int n;
	HF dfs(int x, int p){
		HF res = HF(0, 0);
		int d = 0;
		HF ch[3];
		for (int k = c[x]; ~k; k = nxt[k]){
			int y = g[k];
			if (y == p) continue;
			d++;
			if (d > 2) return HF(0, 0);
			ch[d] = dfs(y, x);
			if (ch[d].ans == 0)
				return HF(0, 0);
		}
		if (d == 0)
			return HF(1, 1);
		if (d == 1){
			if (ch[1].s == 1)
				return HF(1, 2);
			else return HF(0, 0);
		}
		res.s = ch[1].s + ch[2].s + 1;
		res.ans = ch[1].ans * ch[2].ans;
		if (ch[1].s == ch[2].s && ok[ch[1].s + 1]){
			res.ans *= 2;
			//printf("gg %d\n", x);
		}
		else{
			if (ch[1].s == ch[2].s) return HF(0, 0);
			int mn = min(ch[1].s, ch[2].s), mx = max(ch[1].s, ch[2].s);
			if (ok[mn + 1] && lg[mx] == lg[mn + 1])
				{}
			else if (ok[mx + 1] && lg[mn] == lg[mx + 1] - 1)
					{}
				 else return HF(0, 0);
		}
		//printf("[%d] %d\n", x, res.s);
		return res;
	}
	long long countWays(vector <int> knob1, vector <int> knob2) {
		n = knob1.size() + 1;
		memset(c, -1, sizeof c);
		nm = 0;
		LL ans = 0;
		for (int i = 1; i <= n; i *= 2)
			ok[i] = 1;
		lg[1] = 0;
		for (int i = 2; i <= n; ++i)
			lg[i] = lg[i - 1] + ok[i];
		REP(i, n - 1){
			add(knob1[i - 1], knob2[i - 1]);
			add(knob2[i - 1], knob1[i - 1]);
		}
		REP(i, n){
			ans += dfs(i, -1).ans;
			//cout << dfs(i, - 1).ans << endl;
		}
		return ans;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, bool hasAnswer, long long p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}";
	cout << "]" << endl;
	HatRack *obj;
	long long answer;
	obj = new HatRack();
	clock_t startTime = clock();
	answer = obj->countWays(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	vector <int> p1;
	long long p2;
	
	{
	// ----- test 0 -----
	int t0[] = {1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {2};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 2ll;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {1,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {2,3};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 2ll;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {1,1,1,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {2,3,4,5};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 0ll;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {6,6,6,4,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,2,4,5,3};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 0ll;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	int t0[] = {1,1,2,2,11,11,8,8,3,3,4,4,5};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {2,3,11,8,12,13,9,10,4,5,7,6,14};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 16ll;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	int t0[] = {1,2,3,4,5,6,7,8,9};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {2,3,4,5,6,7,8,9,10};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 0ll;
	all_right = KawigiEdit_RunTest(5, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// The Order of the Hats has commissioned the creation of a new hat rack. This new hat rack must meet certain properties in order to be considered to hold headwear of such importance.
// The hat rack is formed by taking several numbered knobs that are connected by rods. One of the knobs is nailed to the wall. The remaining knobs then hang below this top knob. A sample hat rack is shown in the picture below.
// 
// 
// 
// The picture also shows that the hat rack can be divided into levels of knobs. Formally, the level i is defined to contain each knob X such that there are exactly i rods between the top knob and knob X.
// 
// The order would like their hat rack to meet the following three requirements:
// 
// Each knob X can have at most two knobs hanging directly below it. If there is only one such knob, it hangs directly below X; otherwise, one knob will hang slightly to the right of X and the other slightly to the left.
// Except for the bottommost level, each level must be full. That is, if level i is not the bottommost level, it must contain exactly 2^i knobs.
// The bottommost level must have all its knobs as far on the left as possible.
// 
// 
// The third requirement in more detail: Let b be the bottommost level. If we traverse level b-1 from left to right, there will first be some knobs with two rods going to knobs in level b, then possibly a single knob with one rod going to level b, and finally some knobs not connected to any knob in level b.
// 
// You are given a configuration of knobs and rods. The knobs are not fastened to the wall yet. The knobs are numbered 1 through N. There are precisely N-1 rods, and they are connecting the knobs in such a way that the entire structure holds together. (Thus, necessarily, the topology of the hat rack is a tree.)
// 
// You are given two vector <int>s knob1 and knob2, each containing N-1 elements. These two vector <int>s describe the rods: For each i, there is a rod connecting the two knobs knob1[i] and knob2[i]. Return the number of ways to arrange the hat rack such that it meets the requirements set by the Order of the Hats. Two arrangements are considered different if the relative position of at least one pair of knobs differs. If it is not possible to meet the requirements, return 0.
// 
// DEFINITION
// Class:HatRack
// Method:countWays
// Parameters:vector <int>, vector <int>
// Returns:long long
// Method signature:long long countWays(vector <int> knob1, vector <int> knob2)
// 
// 
// NOTES
// -The correct number of arrangements always fits in a signed 64 bit integer.
// 
// 
// CONSTRAINTS
// -knob1 will contain between 1 and 50 elements, inclusive.
// -knob1 and knob2 will contain the same number of elements.
// -Each element of knob1 will be between 1 and N, inclusive, where N is 1 + (the number of elements in knob1).
// -Each element of knob2 will be between 1 and N, inclusive, where N is 1 + (the number of elements in knob2).
// -Each pair of knobs in the hat rack will be connected by some sequence of rods and knobs.
// 
// 
// EXAMPLES
// 
// 0)
// {1}
// {2}
// 
// Returns: 2
// 
// 
// 
// 1)
// {1,1}
// {2,3}
// 
// Returns: 2
// 
// 
// 
// 2)
// {1,1,1,1}
// {2,3,4,5}
// 
// Returns: 0
// 
// 
// 
// 3)
// {6,6,6,4,1}
// {1,2,4,5,3}
// 
// Returns: 0
// 
// 
// 
// 4)
// {1,1,2,2,11,11,8,8,3,3,4,4,5}
// {2,3,11,8,12,13,9,10,4,5,7,6,14}
// 
// Returns: 16
// 
// 
// 
// 5)
// {1,2,3,4,5,6,7,8,9}
// {2,3,4,5,6,7,8,9,10}
// 
// Returns: 0
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
