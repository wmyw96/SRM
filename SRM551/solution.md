# 250pt
## 算法描述
似乎直接暴力就可以了。
## 备注
+0
## tags
暴力
<!--more-->

# 450pt
## 算法描述
注意到设f[x]表示从x到终点要删掉多少个，注意到最优解一定是简单路径，所以就是转移带环的dp，用spfa更新即可
## 备注
+0
## tags
dp，spfa

# 1000pt
## 题目大意
给定N个点，点权在-1到2500W之间，如果一个点的权值>=0说明是好的，否则说明是坏的。
让你用N-1条边把这N个点连起来，要求好好的点的权值之和小于等于S`$S \le 10^9$`，求方案数。
好好的点的定义是：这个点是好的，他连着起码一个好的的点。
`$N\le 40$`
## 算法描述
设好的节点有S个。
如果枚举了哪几个节点是好好的，那么剩下来的就是怎么求这样的树的个数，这时候我们发现这只和好好的节点的个数s有关，那么，我们建一个图，A集合s个点表示好好的的节点，B集合S-s个点表示剩下的有非负权值的节点，C集合N-S个节点表示坏节点。
A集合每个点之间互相连边，C集合里的点向每个点都连一条边，那么，F[x]表示有x个节点是好好节点的值就是这个图的生成树个数？
并不是的！
如果这个图的生成树个数求的是G[x]，那么G[x]表示好好节点的个数`$\le x$`的答案。
更具体的来说，
```mathjax
G[x]=\sum_{k=0}^{x}{\binom{x}{k}F[k]}
```

反演即可得
```mathjax
F[x]=\sum_{k=0}^{x}{(-1)^{x-k}\binom{x}{k}G[k]}
```

这样，只要用生成树的基尔霍夫矩阵算了之后再反演一下就可以得出正确的F[x]了。
那么，剩下来的事情就是怎么枚举？
折半搜索！
复杂度？对于后一半的东西我要枚举前一半**取几个**并且和小于等于某个数？似乎是`$S^2 \times 2^(S/2)$`的？`
不是这样的！我一开始这样写，结果pretest都T掉了。因为是先弄了pair之后对整个序列lowerbound的，但是，发现枚举和二分的复杂度是分开的！当然你要对取几个的那个数组二分，不能对整个二分。枚举+二分的复杂度其实是
```mathjax
O(S+\sum_{k=0}^{S}{\log_2 x_k}) (\sum_{k=1}^{S}{x_k}=(2^{S/2}))
```

的，复杂度最后是
```mathjax
O(S^4+S \cdot 2^{S/2}) 
```
## 备注
+2
WA #1 手残，权值为0的没取。
TLE #1 常数太大，把二分时候的在pair里二分改成用int二分即可。
## tags
基尔霍夫矩阵，生成树计数，反演，折半搜索。