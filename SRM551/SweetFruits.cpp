#include <vector>
#include <map>
#include <set>
#include <queue>
#include <bitset>
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>

using namespace std;

#define X first
#define Y second
#define mk make_pair
#define rep(i, s, t) for (int i = (s); i <= (t); ++i)
#define per(i, s, t) for (int i = (s); i >= (t); --i)
#define REP(i, n) rep(i, 1, n)
#define MOD 1000000007
typedef pair<int, int> PII;
typedef long long LL;
typedef double LD;

class SweetFruits {
public:
	LL g[44][44];
	LL c[44][44];
	LL G[44], T[44];
	PII q[1 << 21];
	int q2[1 << 21];
	int n, N, a[44];
	int bg[44], ed[44];
	
	inline LL rev(LL x){
		LL ret = 1;
		for (int i = 0; i < 31; ++i){
			if (((MOD-2) >> i) & 1)
				ret = ret * x % MOD;
			x = x * x % MOD;
		}
		return ret;
	}
	
	void add(int x, int y){
		g[x][x]++;
		g[y][y]++;
		g[x][y] = g[y][x] = MOD - 1;
	}
	
	LL Matrix_Tree(int s){
		memset(g, 0, sizeof g);
		REP(i, s) REP(j, i - 1) add(i, j);
		REP(i, N) rep(j, N + 1, n) add(i, j);
		rep(i, N + 1, n) rep(j, N + 1, i - 1) add(i, j);
		//REP(i, n) {REP(j, n) printf("%lld ", g[i][j]); puts("");}
		LL res = 1;
		REP(k, n - 1){
			int x = -1;
			rep(i, k, n - 1)
				if (g[i][k] > 0){
					x = i;
					REP(j, n - 1) swap(g[i][j], g[k][j]);
					if (i != k) res = res * (MOD - 1) % MOD;
				}
			if (x == -1) continue;
			rep(i, k + 1, n - 1){
				if (g[i][k] > 0){
					LL o = g[i][k] * rev(g[k][k]) % MOD;
					rep(j, k, n - 1){
						g[i][j] = g[i][j] - g[k][j] * o % MOD;
						if (g[i][j] < 0) g[i][j] += MOD;
					}
				}
			}
		}
		//cout << res << endl;
		REP(i, n - 1)
			res = res * g[i][i] % MOD;
		//cout << res << endl;
		return res;
	}
	
	int countTrees(vector <int> sweetness, int maxSweetness) {
		n = sweetness.size();
		REP(i, n)
			if (sweetness[i - 1] >= 0)
				a[++N] = sweetness[i - 1];

		c[0][0] = 1;
		REP(i, n){
			c[i][0] = 1;
			REP(j, i){
				c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
				//printf("c[%d,%d] = %lld\n", i, j, c[i][j]);
			}
		}
		//cout << c[0][0] << endl;
		rep(s, 0, N){
			G[s] = Matrix_Tree(s);
			//cout << G[s] << endl;
			LL fh = 1;
			
			per(k, s, 0){
				T[s] += fh * c[s][k] * G[k];
				//printf("%d %d %lld\n", s, k, c[s][k]);
				//cout << G[k] << " " << c[s][k] << " " << fh << endl;
				T[s] %= MOD;
				if (T[s] < 0) T[s] += MOD;
				fh *= -1;
			}
		}
		
		int S = (1 << N / 2);
		rep(s, 0, (1 << N/2) - 1){
			int ts = 0, ns = 0;
			rep(i, 0, N / 2 - 1)
				if ((s >> i) & 1){
					++ns;
					ts += a[i + 1];
				}
			q[s] = mk(ns, ts);
		}
		sort(q, q + S);
		REP(i, S){
			if (bg[q[i - 1].X] == 0)
				bg[q[i - 1].X] = i - 1;
			ed[q[i - 1].X] = i;
			q2[i - 1] = q[i - 1].Y;
		}
		
		LL ans = 0;
		rep(s, 0, (1 << N - N/2) - 1){
			int ts = 0, ns = 0;
			rep(i, 0, N - N/2 - 1)
				if ((s >> i) & 1){
					++ns;
					ts += a[i + N/2 + 1];
				}
			int y = maxSweetness - ts;
			if (y < 0) continue;
			for (int k = 0; k <= N / 2; ++k){
				int t1 = lower_bound(q2 + bg[k], q2 + ed[k], y + 1) - q2;
				int t2 = bg[k];
				ans += (t1 - t2) * T[k + ns];
				ans %= MOD;
			}
		}
		return ans;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, int p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << p1;
	cout << "]" << endl;
	SweetFruits *obj;
	int answer;
	obj = new SweetFruits();
	clock_t startTime = clock();
	answer = obj->countTrees(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	int p1;
	int p2;
	
	{
	// ----- test 0 -----
	int t0[] = {1,2,-1,3};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 3;
	p2 = 3;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {1,2,-1,3};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 5;
	p2 = 7;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {-1,-1,2,5,5};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 6;
	p2 = 20;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {2,6,8,4,1,10,-1,-1,-1,-1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 15;
	p2 = 17024000;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	int t0[] = {1078451,-1,21580110,8284711,-1,4202301,3427559,8261270,-1,16176713,22915672,24495540,19236,5477666,12280316,3305896,17917887,564911,22190488,21843923,23389728,14641920,9590140,12909561,20405638,100184,23336457,12780498,18859535,23180993,10278898,5753075,21250919,17563422,10934412,22557980,24895749,7593671,10834579,5606562};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 245243285;
	p2 = 47225123;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Beaver Bindu has found N pairwise different fruits.
// Some of the fruits are sweet, others are bitter.
// You are given a vector <int> sweetness.
// The sweetness of the i-th fruit (0-based index) is sweetness[i].
// Different fruits can have the same sweetness.
// A fruit is bitter if its sweetness is -1.
// 
// 
// Bindu has N-1 pieces of string.
// She can use each of the strings to connect two of the N fruits.
// She wants to use all N-1 strings to connect all N pieces of fruit into a single connected component.
// I.e., once she is done connecting the fruit, she will have an N-vertex tree, each fruit being one of the N vertices.
// 
// 
// Having such a tree, we can evaluate its total sweetness as follows:
// A fruit on a tree is called truly sweet if it is sweet, and it is connected by a string to some other sweet fruit.
// The total sweetness of a tree is the sum of the sweetness of its truly sweet fruits.
// 
// 
// You are also given a int maxSweetness.
// Let X be the number of possible trees which have total sweetness at most maxSweetness, inclusive.
// Compute and return the value (X modulo 1,000,000,007).
// 
// 
// DEFINITION
// Class:SweetFruits
// Method:countTrees
// Parameters:vector <int>, int
// Returns:int
// Method signature:int countTrees(vector <int> sweetness, int maxSweetness)
// 
// 
// NOTES
// -A tree is an undirected acyclic graph.
// 
// 
// CONSTRAINTS
// -sweetness will contain between 1 and 40 elements, inclusive.
// -Each element of sweetness will be between -1 and 25,000,000, inclusive.
// -maxSweetness will be between 0 and 1,000,000,000 (10^9), inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// {1, 2, -1, 3}
// 3
// 
// Returns: 3
// 
// The following picture shows all 3 trees whose sweetness is at most 3 (truly sweet fruits are painted red).
// 
// 
// 
// 
// 1)
// {1, 2, -1, 3}
// 5
// 
// Returns: 7
// 
// When maxSweetness = 5, the following 4 additional trees are possible.
// 
// 
// 
// 
// 2)
// {-1, -1, 2, 5, 5}
// 6
// 
// Returns: 20
// 
// 3)
// {2, 6, 8, 4, 1, 10, -1, -1, -1, -1}
// 15
// 
// Returns: 17024000
// 
// 4)
// {1078451, -1, 21580110, 8284711, -1, 4202301, 3427559, 8261270, -1, 16176713,
// 22915672, 24495540, 19236, 5477666, 12280316, 3305896, 17917887, 564911, 22190488, 21843923,
// 23389728, 14641920, 9590140, 12909561, 20405638, 100184, 23336457, 12780498, 18859535, 23180993,
// 10278898, 5753075, 21250919, 17563422, 10934412, 22557980, 24895749, 7593671, 10834579, 5606562}
// 245243285
// 
// Returns: 47225123
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
