#include <vector>
#include <map>
#include <set>
#include <queue>
#include <bitset>
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>

using namespace std;

#define X first
#define Y second
#define mk make_pair
#define rep(i, s, t) for (int i = (s); i <= (t); ++i)
#define REP(i, n) rep(i, 1, n)
#define MOD 1000000007
typedef pair<int, int> PII;
typedef long long LL;
typedef double LD;

class Seatfriends {
public:
	LL c[2222][2222];
	int f[2222][2222];
	int N, K, G;
	int adv(int x, int y){
		if (x == 0)
			return y == 1 ? 1 : 0;
		return c[x - 1][y - 1];
	}
	void relax(int &x, int y){
		x += y;
		if (x >= MOD) x -= MOD;
	}
	int calc(int k, int g){
		if (k - 1 + g > N && g > 1)
			return 0;
		if (k > K){
			//printf("%d %d\n", g, adv(N - K, g));
			return adv(N - K, g);
		}
		int &res = f[k][g];
		if (res != -1) return res;
		res = 0;
		if (g + 1 <= G)
			relax(res, calc(k + 1, g + 1) * LL(g) % MOD);
		if ((g == 1) && (k == K) && (K == N))
			relax(res, calc(k + 1, g));
		else relax(res, 2LL * g * calc(k + 1, g) % MOD);
		if (g > 1) relax(res, LL(g) * calc(k + 1, g - 1) % MOD);
		//printf("f[%d,%d] =  %d\n", k, g, f[k][g]);
		return res;
	}
	int countseatnumb(int _N, int _K, int _G) {
		memset(f, -1, sizeof f);
		N = _N;
		K = _K;
		G = _G;
		c[0][0] = 1;
		REP(i, 2000){
			c[i][0] = c[i][i] = 1;
			REP(j, i) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
		}
		return calc(2, 1) * LL(N) % MOD;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, int p2, bool hasAnswer, int p3) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2;
	cout << "]" << endl;
	Seatfriends *obj;
	int answer;
	obj = new Seatfriends();
	clock_t startTime = clock();
	answer = obj->countseatnumb(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p3 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	int p1;
	int p2;
	int p3;
	
	{
	// ----- test 0 -----
	p0 = 3;
	p1 = 2;
	p2 = 1;
	p3 = 6;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 4;
	p1 = 2;
	p2 = 1;
	p3 = 8;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 2;
	p1 = 2;
	p2 = 1;
	p3 = 2;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 5;
	p1 = 4;
	p2 = 2;
	p3 = 120;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = 42;
	p1 = 23;
	p2 = 7;
	p3 = 917668006;
	all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Hero is preparing a party for his friends. He has a round table with N seats. The seats are numbered 0 through N-1, in order. In other words, seats with consecutive numbers are adjacent, and seat N-1 is adjacent to seat 0.
// 
// Hero knows that exactly K friends will attend the party, and that each of them will arrive at a different time. Each time a new friend arrives, Hero has to assign him (or her) one of the empty seats at the table. The friend then sits there for the rest of the party. Hero is not sitting at the table.
// 
// For the purpose of this problem, a cluster is a maximal group of people that occupy consecutive chairs. For example, if there are people on chairs 3, 4, 5, and 6, while chairs 2 and 7 are empty, then these four people form a cluster.
// 
// At a party, clusters are good: people who sit in a cluster can talk to each other and have fun. A party with too many clusters is bad. Therefore, Hero wants to make sure that at no point in time are there more than G clusters at his table.
// 
// For example, let N = 4 and K = 3. That is, we have a table with four seats, and three friends are going to arrive. We will use A, B, and C to denote the three friends (in the order in which they arrive) and a period ('.') to denote an empty chair. So, for example, "ABC." denotes that A got seat 0, B seat 1, C seat 2, and seat 3 remained empty. The configurations ".ABC" and "C.AB" are considered different from "ABC." and from each other: the friends sit in the same order but on different seats.
// 
// Continuing our example, let G = 1. That is, we must never have more than one cluster. This constraint restricts the set of possible final configurations. For example, "ABC.", "C.AB", "B.CA", and ".BAC" are all possible, but "A.BC" and ".ACB" are not. (Note that if the final configuration were "A.BC", then the configuration before C arrived was "A.B.", which means that there was more than one cluster at that point in time.)
// 
// You are given the ints N, K, and G. Count the number of possible final configurations. Return that count modulo 1,000,000,007.
// 
// DEFINITION
// Class:Seatfriends
// Method:countseatnumb
// Parameters:int, int, int
// Returns:int
// Method signature:int countseatnumb(int N, int K, int G)
// 
// 
// CONSTRAINTS
// -N will be between 2 and 2000, inclusive.
// -K will be between 1 and N, inclusive.
// -G will be between 1 and K, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 3
// 2
// 1
// 
// Returns: 6
// 
// There are 6 ways how to seat your 2 friends: "AB.", "A.B", "BA.", "B.A", ".AB", and ".BA". All 6 are valid.
// 
// 1)
// 4
// 2
// 1
// 
// Returns: 8
// 
// The first friend can take any of the four seats. The second one must then sit next to him (on either side). Thus, there are 4*2=8 valid final configurations.
// 
// 2)
// 2
// 2
// 1
// 
// Returns: 2
// 
// 
// 
// 3)
// 5
// 4
// 2
// 
// Returns: 120
// 
// 
// 
// 4)
// 42
// 23
// 7
// 
// Returns: 917668006
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
