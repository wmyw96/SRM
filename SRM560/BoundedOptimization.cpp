#include <vector>
#include <map>
#include <set>
#include <queue>
#include <bitset>
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>

using namespace std;

#define X first
#define Y second
#define mk make_pair
#define rep(i, s, t) for (int i = (s); i <= (t); ++i)
#define REP(i, n) rep(i, 1, n)
typedef pair<int, int> PII;
typedef long long LL;
typedef double LD;

class BoundedOptimization {
public:
	int maxSum;
	int n, low[22], up[22], g[22][22];
	LD ans;
	LD v[22];
	int inS[22];
	int a[22];
	
	void calc(int x, int s, int k){
		if (s > maxSum) return;
		if (x > n){
			REP(i, n) REP(j, i - 1)
				if (inS[i] && inS[j] && g[i][j] == 0)
					return;
			int M = maxSum - s, aSum = 0;
			REP(i, n)
				if (inS[i]) aSum += a[i];
			REP(i, n)
				if (inS[i]){
					v[i] = 1.0 * (M - aSum) / k + a[i];
					if (v[i] < low[i] || v[i] > up[i])
						return;
				}
			LD t = 0;
			REP(i, n) REP(j, i - 1)
				if (g[i][j]) t += v[i] * v[j];
			ans = max(ans, t);
			return;
		}
		inS[x] = 1;
		calc(x + 1, s, k + 1);
		inS[x] = 0;
		
		v[x] = low[x];
		REP(i, n) if (g[i][x]) a[i] += low[x];
		calc(x + 1, s + low[x], k);
		REP(i, n) if (g[i][x]) a[i] -= low[x];
		
		v[x] = up[x];
		REP(i, n) if (g[i][x]) a[i] += up[x];
		calc(x + 1, s + up[x], k);
		REP(i, n) if (g[i][x]) a[i] -= up[x];
	}
	
	double maxValue(vector <string> expr, vector <int> lowerBound, vector <int> upperBound, int maxSum) {
		n = lowerBound.size();
		ans = 0;
		REP(i, n){
			low[i] = lowerBound[i - 1];
			up[i] = upperBound[i - 1];
		}
		string nw = "";
		REP(i, expr.size())
			nw += expr[i - 1];
		for (int i = 0; i < nw.size(); i += 3){
			int x = nw[i] - 'a' + 1;
			int y = nw[i + 1] - 'a' + 1;
			g[x][y] = g[y][x] = 1;
		}
		this->maxSum = maxSum;
		ans = 0.0;
		calc(1, 0, 0);
		return ans;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, vector <int> p1, vector <int> p2, int p3, bool hasAnswer, double p4) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p2[i];
	}
	cout << "}" << "," << p3;
	cout << "]" << endl;
	BoundedOptimization *obj;
	double answer;
	obj = new BoundedOptimization();
	clock_t startTime = clock();
	answer = obj->maxValue(p0, p1, p2, p3);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p4 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == answer && fabs(p4 - answer) <= 1e-9 * max(1.0, fabs(p4));
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	vector <int> p1;
	vector <int> p2;
	int p3;
	double p4;
	
	{
	// ----- test 0 -----
	string t0[] = {"ba+cb"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {0,0,1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {1,2,1};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = 3;
	p4 = 2.25;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"ab"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {0,0,10};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {20,20,20};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = 12;
	p4 = 1.0;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"ca+fc+fa+d","b+da+","dc+c","b","+ed+eb+ea"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {10,11,12,13,14,15};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {15,16,17,18,19,20};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = 85;
	p4 = 2029.25;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"db+ea+ik+kh+je+","fj+lk+i","d+jb+h","a+gk+mb+ml+lc+mh+cf+fd+","gc+ka+gf+bh+mj+eg+bf+hf+l","b+al+ja+da+i","f+g","h+ia+le+ce+gi+d","h+mc+fe+dm+im+kb+bc+","ib+ma+eb+mf+jk+kc+mg+mk+","gb+dl+ek+hj+dg+hi","+ch+ga+ca+fl+ij+fa+jl+dc+dj+fk","+li+jg"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {57,29,50,21,49,29,88,33,84,76,95,55,11};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {58,80,68,73,52,84,100,79,93,98,95,69,97};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = 845;
	p4 = 294978.3333333333;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// You are given an arithmetic expression.
// The expression is a sum of one or more terms.
// Each term is a product of exactly two variables.
// In each term, the two variables are distinct.
// No two terms contain the same pair of variables.
// 
// 
// 
// Additionally, the following constraints are given:
// 
// For each i, the i-th variable (0-based index) must have a value between lowerBound[i] and upperBound[i], inclusive. The bounds are integers, but the value of the variable can be any real number in the given range.
// The sum of all variables must not exceed maxSum.
// 
// 
// 
// 
// You are given a vector <string> expr, the vector <int>s lowerBound and upperBound, and the int maxSum.
// Concatenate the elements of expr to obtain the considered expression.
// For each i, the i-th variable will be denoted by the i-th lowercase letter of the English alphabet.
// (Both indices are 0-based, so variable 0 is 'a', variable 1 is 'b', and so on.)
// 
// 
// 
// Return the maximum value of the expression, given that all the above constraints have to be satisfied.
// Note that the constraints guarantee that it is possible to satisfy all the given constraints.
// 
// 
// DEFINITION
// Class:BoundedOptimization
// Method:maxValue
// Parameters:vector <string>, vector <int>, vector <int>, int
// Returns:double
// Method signature:double maxValue(vector <string> expr, vector <int> lowerBound, vector <int> upperBound, int maxSum)
// 
// 
// NOTES
// -Your return value must have a relative or an absolute error of less than 1e-9.
// 
// 
// CONSTRAINTS
// -expr will contain between 1 and 50 elements, inclusive.
// -Each element of expr will contain between 1 and 50 characters, inclusive.
// -Each character in each element of expr will be '+' or one of the first n lowercase letters of the English alphabet, where n is the number of elements in lowerBound.
// -The concatenation of the elements of expr will consist of pairs of letters separated by '+' characters.
// -No unordered pair of consecutive letters will appear twice in the concatenation of the elements of expr.
// -No two consecutive letters in the concatenation of the elements of expr will be equal.
// -lowerBound will contain between 2 and 13 elements, inclusive.
// -Each element of lowerBound will be between 0 and 100, inclusive.
// -upperBound will contain n elements, where n is the number of elements in lowerBound.
// -For each i between 0 and n - 1, the i-th element of upperBound will be between lowerBound[i] and 100, inclusive.
// -maxSum will be between the sum of the elements of lowerBound and 1,300, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// {"ba+cb"}
// {0,0,1}
// {1,2,1}
// 3
// 
// Returns: 2.25
// 
// The maximum value is obtained by setting a = 0.5, b = 1.5, c = 1.
// 
// 1)
// {"ab"}
// {0, 0, 10}
// {20, 20, 20}
// 12
// 
// Returns: 1.0
// 
// We have to set a proper value for c even though it is not present in the expression described by expr.
// 
// 2)
// {"ca+fc+fa+d","b+da+","dc+c","b","+ed+eb+ea"}
// {10,11,12,13,14,15}
// {15,16,17,18,19,20}
// 85
// 
// Returns: 2029.25
// 
// 
// 
// 3)
// {"db+ea+ik+kh+je+","fj+lk+i","d+jb+h","a+gk+mb+ml+lc+mh+cf+fd+","gc+ka+gf+bh+mj+eg+bf+hf+l","b+al+ja+da+i",
// "f+g","h+ia+le+ce+gi+d","h+mc+fe+dm+im+kb+bc+","ib+ma+eb+mf+jk+kc+mg+mk+","gb+dl+ek+hj+dg+hi","+ch+ga+ca+fl+ij+fa+jl+dc+dj+fk","+li+jg"}
// {57,29,50,21,49,29,88,33,84,76,95,55,11}
// {58,80,68,73,52,84,100,79,93,98,95,69,97}
// 845
// 
// Returns: 294978.3333333333
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
